# 분산 환경에서의 동시성 제어 메커니즘

## 각 메커니즘의 한계

1. **낙관적 락(Optimistic Locking)** - 제한적으로 가능
   - 데이터베이스 레벨에서 작동하므로 분산 환경에서도 유효함
   - 하지만 충돌 발생 시 재시도 로직이 필요하며 사용자 경험 저하 가능성
   - 경합이 심한 인기 경매에서는 성능 저하 우려

2. **세마포어(Semaphore)** - 분산 환경에서 동시성 제어 불가
   - Java의 Semaphore는 단일 JVM 내에서만 유효
   - 서버 A의 세마포어가 서버 B에 영향을 주지 않음
   - 분산 환경에서 동시 입찰 제어 불가

3. **tryLock** - 분산 환경에서 동시성 제어 불가
   - ReentrantLock의 tryLock()도 단일 JVM 내 제한
   - 서버 간 락 정보 공유 불가능
   - 여러 서버에서 중복 입찰 처리 가능성

4. **synchronized** - 분산 환경에서 동시성 제어 불가
   - JVM 레벨 동기화로 분산 환경에서 의미 없음
   - 여러 서버 인스턴스 간 동기화 기능 없음
   - 서버마다 독립적으로 입찰 처리 가능

## 분산 환경의 경매 시스템 솔루션

1. **Redis 기반 분산 락**
   - **장점**:
     - 빠른 처리 속도와 낮은 지연시간
     - 구현이 상대적으로 간단함
     - TTL(Time-To-Live) 설정으로 데드락 방지
   - **구현 방법**:
     - Spring의 `RedisLockRegistry` 활용
     - Redis의 `SETNX` 명령어와 Lua 스크립트로 원자적 연산 구현
     - 락 획득 실패 시 재시도 또는 폴백 메커니즘 구현

2. **데이터베이스 수준의 락**
   - **장점**:
     - 별도 인프라 없이 기존 DB 활용
     - 트랜잭션과 자연스러운 통합
     - 레코드 수준의 세밀한 락 제어 가능
   - **구현 방법**:
     - JPA의 `@Lock(LockModeType.PESSIMISTIC_WRITE)` 활용
     - 명시적 `SELECT FOR UPDATE` 쿼리 사용
     - 트랜잭션 타임아웃 설정으로 장시간 블로킹 방지

***

## 학습을 통한 인사이트

1. **지식의 확장성**
   - 동시성 제어 하나를 깊게 이해하면 고려해야 할 요소가 오히려 늘어남
   - 단일 서버 환경과 분산 서버 환경의 근본적인 차이를 실제로 체감
   - 이론적 이해를 넘어 실제 구현에서 마주치는 문제들의 복잡성

2. **서버의 Stateless 특성 이해**
   - 웹 서버가 상태를 유지하지 않는(stateless) 특성이 동시성 제어에 미치는 영향
   - 서버 메모리에 저장된 락/세마포어는 다른 서버와 공유 불가능
   - 확장 가능한 시스템을 구축할 때 stateless 서버의 중요성

3. **분산 상태 관리의 필요성**
   - 서버 간 상태 공유를 위해 Redis, DB와 같은 외부 시스템이 필수적
   - 단순해 보이던 문제가 분산 환경에서는 복잡한 아키텍처 결정으로 이어짐
   - 토이 프로젝트지만 실제 대규모 서비스의 설계 원칙을 경험할 수 있는 기회

***
