# 분산 환경에서 Quartz 클러스터링 동작 원리

## 시나리오 예시

- 서버 A, B, C가 같은 DB 그룹(복제 O, 샤딩 X)에 연결된 상태
- 서버 A에서 경매가 시작되고, 종료 작업이 Quartz에 스케줄링됨
- 경매 종료 시간이 임박했을 때 서버 A가 다운됨

## Quartz 클러스터링의 장애 복구 메커니즘

### 1. 인스턴스 체크인(Heartbeat)
- 모든 Quartz 인스턴스는 주기적으로 DB에 "체크인"하여 자신이 살아있음을 알림
- 기본 체크인 주기: 15초(설정 가능)

### 2. 장애 감지
- 서버 A가 더 이상 체크인하지 않으면, 클러스터의 다른 서버(B, C)가 이를 감지

### 3. 작업 복구(Failover)
- 일정 시간(기본 60초) 후, 서버 B 또는 C가 서버 A의 미처리 작업을 인수
- 서버 A의 상태를 "실패"로 표시하고, 해당 작업을 자신의 실행 대기열에 추가

### 4. 작업 실행
- 경매 종료 시간이 되면, 서버 B 또는 C가 해당 작업을 실행
- `AuctionEndJob`이 정상적으로 실행되어 경매가 종료됨

---

## Quartz 클러스터링을 위한 주요 설정

```yaml
spring:
  quartz:
    job-store-type: jdbc   # DB에 작업 저장
    properties:
      org.quartz.jobStore.isClustered: true   # 클러스터링 활성화
```

- 모든 작업 정보가 DB에 저장되어, 클러스터 내 모든 노드가 작업 정보에 접근 가능
- 한 노드가 실패해도 다른 노드가 작업을 이어받아 실행

---

## 주의사항

- **데이터베이스 복제 지연**  
  DB 복제가 느릴 경우, 작업 복구가 지연될 수 있으므로 복제 지연을 최소화해야 함

- **서버 시간 동기화**  
  모든 서버의 시스템 시간이 정확히 동기화되어야 함(NTP 등 사용 권장)

- **Misfire(지연 실행) 설정**  
  `misfireThreshold` 등 Quartz 설정을 통해 지연된 작업 처리 방식을 조정할 수 있음(기본 60초)

---

## 결론

Quartz 클러스터링을 사용하면,  
**서버 장애 상황에서도 경매 시작/종료와 같은 중요한 작업이 다른 서버에서 자동으로 복구 및 실행**되어  
고가용성(HA) 환경을 구현할 수 있습니다.
